#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START V5 MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END V5 MACROS


// Robot configuration code.
controller Controller1 = controller(primary);
motor BackLeft = motor(PORT4, ratio18_1, false);

motor BackRight = motor(PORT1, ratio18_1, true);

motor FrontRight = motor(PORT2, ratio18_1, true);

motor FrontLeft = motor(PORT3, ratio18_1, false);

motor BottomIntake = motor(PORT11, ratio18_1, false);

motor TopPole = motor(PORT13, ratio18_1, true);

motor TopIntake = motor(PORT12, ratio18_1, false);

motor MiddlePole = motor(PORT14, ratio18_1, false);

/*vex-vision-config:begin*/
vision::signature Vision20__BLUECUBE = vision::signature (1, -4369, -2803, -3586,6593, 8843, 7718,2.5, 0);
vision::signature Vision20__REDCUBE = vision::signature (2, 11239, 13065, 12152,-1663, -429, -1046,2.5, 0);
vision Vision20 = vision (PORT20, 50, Vision20__BLUECUBE, Vision20__REDCUBE);
/*vex-vision-config:end*/
motor Shaker = motor(PORT5, ratio36_1, false);



// generating and setting random seed
void initializeRandomSeed(){
  int systemTime = Brain.Timer.systemHighResolution();
  double batteryCurrent = Brain.Battery.current();
  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);

  // Combine these values into a single integer
  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;

  // Set the seed
  srand(seed);
}



void vexcodeInit() {

  //Initializing random seed.
  initializeRandomSeed(); 
}


// Helper to make playing sounds from the V5 in VEXcode easier and
// keeps the code cleaner by making it clear what is happening.
void playVexcodeSound(const char *soundName) {
  printf("VEXPlaySound:%s\n", soundName);
  wait(5, msec);
}



// define variable for remote controller enable/disable
bool RemoteControlCodeEnabled = true;

#pragma endregion VEXcode Generated Robot Configuration

// ----------------------------------------------------------------------------
//                                                                            
//    Project:                                               
//    Author:
//    Created:
//    Configuration:        
//                                                                            
// ----------------------------------------------------------------------------

// Include the V5 Library
#include "vex.h"

// Allows for easier use of the VEX Library
using namespace vex;

// Begin project code

bool aboveLine(double x, double y, double px1, double py1, double px2, double py2) {
  return (py2 - py1) * (x - px1) / (px2 - px1) + py1 <= y;
}

void drawStar() {
  double pi = 3.1415926535;
  double xVals[5] = {cos(pi / 10.0), 0, cos(pi - pi / 10.0), cos(pi + 3 * pi / 10), cos(2 * pi - 3 * pi / 10)};
  double yVals[5] = {sin(pi / 10.0), 1, sin(pi - pi / 10.0), sin(pi + 3 * pi / 10), sin(2 * pi - 3 * pi / 10)};

  for(int x = 0; x < 239; x++) {
    double mappedX = (x * 2.0 / 239.0 - 1) * -1;
    for(int y = 10; y < 249; y++) {
      double mappedY = ((y-10) * 2.0 / 239.0 - 1) * -1;

      if(mappedY > yVals[0]) {
        if(!aboveLine(mappedX, mappedY, xVals[1], yVals[1], xVals[3], yVals[3]) && !aboveLine(mappedX, mappedY, xVals[1], yVals[1], xVals[4], yVals[4])) {
          Brain.Screen.drawPixel(x, y);
        }
      } else if(aboveLine(mappedX, mappedY, xVals[2], yVals[2], xVals[4], yVals[4])) {
        if(aboveLine(mappedX, mappedY, xVals[0], yVals[0], xVals[3], yVals[3])) {
          Brain.Screen.drawPixel(x, y);
        } else if(!aboveLine(mappedX, mappedY, xVals[1], yVals[1], xVals[4], yVals[4])) {
          Brain.Screen.drawPixel(x, y);
        }
      } else if(aboveLine(mappedX, mappedY, xVals[0], yVals[0], xVals[3], yVals[3]) && !aboveLine(mappedX, mappedY, xVals[1], yVals[1], xVals[3], yVals[3])) {
        Brain.Screen.drawPixel(x, y);
      }
    }
  }
}

void drawTexanFlag() {
  Brain.Screen.clearScreen();
  Brain.Screen.setFillColor(blue);
  Brain.Screen.drawRectangle(0, 0, 239, 239);
  Brain.Screen.setFillColor(white);
  Brain.Screen.drawRectangle(239, 0, 239, 239 / 2);
  Brain.Screen.setFillColor(red);
  Brain.Screen.drawRectangle(239, 239 / 2, 239, 239);
  
  Brain.Screen.setFillColor(white);
  drawStar();
}

double biState = 0;
double tpState = 0;
double tiState = 0;
double mpState = 0;
double counter = 0;
double armCounter = 0;

bool isIntaking = false;
bool isOutaking = false;
bool isRedAlliance = true;
bool isRightSide = true;
bool isShakerSet = false;

void setAlliance() {
  int brainWidth = 480;
  int brainHeight = 240;
  Brain.Screen.clearScreen();
  Brain.Screen.setFillColor(red);
  Brain.Screen.drawRectangle(0, 0, brainWidth / 2, brainHeight);
  Brain.Screen.setFillColor(blue);
  Brain.Screen.drawRectangle(brainWidth / 2, 0, brainWidth / 2, brainHeight);
  while (!Brain.Screen.pressing()) {
    wait(0.1, seconds);
  }
  while (Brain.Screen.pressing()) {
    wait(0.1, seconds);
  }
  if(Brain.Screen.xPosition() < brainWidth / 2) {
    isRedAlliance = true;
  } else {
    isRedAlliance = false;
  }
  Brain.Screen.clearScreen();

  Brain.Screen.setFillColor(orange);
  Brain.Screen.drawRectangle(0, 0, brainWidth / 2, brainHeight);
  Brain.Screen.setFillColor(yellow);
  Brain.Screen.drawRectangle(brainWidth / 2, 0, brainWidth / 2, brainHeight);
  while (!Brain.Screen.pressing()) {
    wait(0.1, seconds);
  }
  if(Brain.Screen.xPosition() > brainWidth / 2) {
    isRightSide = true;
  } else {
    isRightSide = false;
  }

  if(isRedAlliance) {
    Brain.Screen.setFillColor(red);
  } else {
    Brain.Screen.setFillColor(blue);
  }
  Brain.Screen.drawRectangle(0, 0, brainWidth, brainHeight);
  Brain.Screen.setCursor(1, 1);
  Brain.Screen.print(isRightSide ? "Right Auton" : "Left Auton");
}

void intakeStop() {
  isIntaking = false;
  isOutaking = false;
  biState = 0;
  tpState = 0;
  tiState = 0;
  mpState = 0;
}

void intakeScoreTop() {
  isIntaking = false;
  isOutaking = true;
  biState = 1;
  tpState = 1;
  tiState = 1;
  mpState = 1;
}

void spinToScoreMiddle() {
  biState = 1;
  tpState = 0.5;
  tiState = -1;
  mpState = 0;
}

void intakeScoreMiddle() {
  isOutaking = true;
  isIntaking = false;
  spinToScoreMiddle();
  mpState = 1;
}

void intakeStore() {
  isIntaking = true;
  isOutaking = false;
  biState = 1;
  tpState = -1;
  tiState = 1;
  mpState = 0;
}

void intakeUnstore() {
  isIntaking = false;
  isOutaking = true;
  biState = -1;
  tpState = -1;
  tiState = -1;
  mpState = 1;
}

void setShaker() {
  Shaker.setMaxTorque(1, percent);
  Shaker.spin(forward, 10, volt);
  wait(1, seconds);
  Shaker.setPosition(45, degrees);
  Shaker.spinToPosition(0, degrees, false);
  Shaker.setMaxTorque(100, percent);
  isShakerSet = true;
}

void updateMovementMotors() {
  FrontRight.spin(forward, (Controller1.Axis3.position() - Controller1.Axis1.position()) / 90.0 * 12, volt);
  BackRight.spin(forward, (Controller1.Axis3.position() - Controller1.Axis1.position()) / 90.0 * 12, volt);
  FrontLeft.spin(forward, (Controller1.Axis3.position() + Controller1.Axis1.position()) / 90.0 * 12, volt);
  BackLeft.spin(forward, (Controller1.Axis3.position() + Controller1.Axis1.position()) / 90.0 * 12, volt);
}

bool doesSeeFriendlyCube() {
  vision::signature friendlyCube = (isRedAlliance ? Vision20__REDCUBE : Vision20__BLUECUBE);
  Vision20.takeSnapshot(friendlyCube);
  return Vision20.objects[0].exists;
}

bool doesSeeEnemyCube() {
  vision::signature hostileCube = (isRedAlliance ? Vision20__BLUECUBE : Vision20__REDCUBE);
  Vision20.takeSnapshot(hostileCube);
  return Vision20.objects[0].exists;
}

void updateColorFilter() {
  if(!isIntaking) { return; }

  if(doesSeeEnemyCube() && counter > 2) {
    spinToScoreMiddle();
  } else if(doesSeeFriendlyCube()) {
    counter = 0;
    intakeStore();
  }

  counter++;
}



void updateShakerArm() {
  if(isOutaking) {
    int pos = armCounter > 10 ? -45 : 45;
    Shaker.spinToPosition(pos, degrees, false);
  } else if(Shaker.isDone()) {
    Shaker.spinToPosition(50, degrees, false);
  }
  if(armCounter > 20) {
    armCounter = 0;
  }
  armCounter++;
}

void updateIntakeMotors() {
  updateColorFilter();
  BottomIntake.spin(forward, 10 * biState, volt);
  TopPole.spin(forward, 11 * tpState, volt);
  TopIntake.spin(forward, 5.5 * tiState, volt);
  MiddlePole.spin(forward, 5.5 * mpState, volt);

  updateShakerArm();
}

void driveForeward(double squares) {
  double constant = 24 / (4 * 3.1415926535);
  BackRight.spinFor(forward, squares * constant, turns, false);
  FrontRight.spinFor(forward, squares * constant, turns, false);
  BackLeft.spinFor(forward, squares * constant, turns, false);
  FrontLeft.spinFor(forward, squares * constant, turns);
  // wait(0.1, seconds);
}

void turnRight(double degree) {
  BackRight.setPosition(0, degrees);
  FrontRight.setPosition(0, degrees);
  BackLeft.setPosition(0, degrees);
  FrontLeft.setPosition(0, degrees);
  // double constant = sqrt(4.5 * 4.5 + 11.75 * 11.75) / 4.0 / 180.0 * 2 / 3;
  double d = sqrt(4.5 * 4.5 + 11.75 * 11.75);
  double constant = d / 4.0 / 360.0 / 3 * 4;
  BackRight.spinFor(reverse, degree * constant, turns, false);
  FrontRight.spinFor(reverse, degree * constant, turns, false);
  BackLeft.spinFor(forward, degree * constant, turns, false);
  FrontLeft.spinFor(forward, degree * constant, turns);
  // wait(0.1, seconds);
}

void turnLeft(double degree) {
  turnRight(-degree);
}

void setVelocities(double per) {
  BackLeft.setVelocity(per, percent);
  BackRight.setVelocity(per, percent);
  FrontRight.setVelocity(per, percent);
  FrontLeft.setVelocity(per, percent);
}

void setStoppingTo(vex::brakeType b) {
  BackLeft.setStopping(b);
  BackRight.setStopping(b);
  FrontRight.setStopping(b);
  FrontLeft.setStopping(b);
}

void rightAutonomous() {
  setVelocities(80);
  setStoppingTo(hold);
  intakeStore();
  updateIntakeMotors();
  // turnLeft(3);
  driveForeward(0.5);
  turnRight(80);
  driveForeward(0.3);
  turnLeft(90 * 4 / 3 + 30);
  setVelocities(40);
  driveForeward(1);
  // driveForeward(0.6);
  wait(0.5, seconds);
  driveForeward(-0.25);
  turnLeft(60);
  driveForeward(0.75);
  intakeUnstore();
  for(int i = 0; i < 100; i++) {
    updateIntakeMotors();
    wait(0.05, seconds);
  }
  intakeStop();
  updateIntakeMotors();
  driveForeward(-0.5);
  

  // turnRight(-90);
  // driveForeward(0.6);
  // driveForeward(-0.6);
  // turnRight(90);
}
void leftAutonomous() {
  setVelocities(80);
  setStoppingTo(hold);
  // turnLeft(2);
  intakeStore();
  driveForeward(1);
  turnLeft(55);
  updateIntakeMotors();
  setVelocities(20);
  driveForeward(0.76);
  
  wait(0.5, seconds);
  turnRight(72);
  driveForeward(0.7);
  intakeScoreMiddle();
  for(int i = 0; i < 100; i++) {
    updateIntakeMotors();
    wait(0.05, seconds);
  }
  intakeStop();
  updateIntakeMotors();
  driveForeward(-0.5);
}

void autonomous() {
  setShaker();
  drawTexanFlag();
  if(isRightSide) {
    rightAutonomous();
  } else {
    leftAutonomous();
  }

}

void userControl() {
  if(!isShakerSet) {
    setShaker();
  }
  // place driver control in this while loop
  while (true) {
    updateMovementMotors();
    updateIntakeMotors();
    wait(20, msec);
  }
}

void turnRightTester() {
  turnRight(90);
}

void preAutonomous() {
  // actions to do when the program starts
  Controller1.ButtonX.pressed(intakeStop);
  Controller1.ButtonR1.pressed(intakeScoreTop);
  Controller1.ButtonR2.pressed(intakeScoreMiddle);
  Controller1.ButtonL1.pressed(intakeStore);
  Controller1.ButtonL2.pressed(intakeUnstore);
  Controller1.ButtonA.pressed(turnRightTester);
  setAlliance();
  
  wait(1, seconds);
}

int main() {
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();
  // create competition instance
  competition Competition;

  // Set up callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(userControl);

  // Run the pre-autonomous function.
  preAutonomous();

  // Prevent main from exiting with an infinite loop.
  while (true) {
    wait(100, msec);
  }
}
