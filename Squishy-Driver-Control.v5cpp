{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\ncontroller Controller1 = controller(primary);\nmotor BackLeft = motor(PORT14, ratio18_1, false);\n\nmotor BackRight = motor(PORT6, ratio18_1, true);\n\nmotor FrontRight = motor(PORT5, ratio18_1, true);\n\nmotor FrontLeft = motor(PORT15, ratio18_1, false);\n\nmotor BottomIntake = motor(PORT3, ratio18_1, false);\n\nmotor TopPole = motor(PORT1, ratio18_1, true);\n\nmotor TopIntake = motor(PORT2, ratio18_1, false);\n\nmotor MiddlePole = motor(PORT12, ratio18_1, false);\n\n/*vex-vision-config:begin*/\nvision::signature ColorSorter__BLUECUBE = vision::signature (1, -4369, -2803, -3586,6593, 8843, 7718,2.5, 0);\nvision::signature ColorSorter__REDCUBE = vision::signature (2, 11239, 13065, 12152,-1663, -429, -1046,2.5, 0);\nvision ColorSorter = vision (PORT11, 50, ColorSorter__BLUECUBE, ColorSorter__REDCUBE);\n/*vex-vision-config:end*/\nmotor Shaker = motor(PORT9, ratio36_1, false);\n\ninertial InertialSensor = inertial(PORT10);\n\ndigital_out PnumaticLoader = digital_out(Brain.ThreeWirePort.H);\ndigital_out Descorer = digital_out(Brain.ThreeWirePort.G);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n// ----------------------------------------------------------------------------\n//                                                                            \n//    Project:                                               \n//    Author:                                 Eli Sur\n//    Created:\n//    Configuration:        \n//                                                                            \n// ----------------------------------------------------------------------------\n\n// Include the V5 Library\n#include \"vex.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// Begin project code\n\nbool aboveLine(double x, double y, double px1, double py1, double px2, double py2) {\n  return (py2 - py1) * (x - px1) / (px2 - px1) + py1 <= y;\n}\n\nvoid drawStar() {\n  double pi = 3.1415926535;\n  double xVals[5] = {cos(pi / 10.0), 0, cos(pi - pi / 10.0), cos(pi + 3 * pi / 10), cos(2 * pi - 3 * pi / 10)};\n  double yVals[5] = {sin(pi / 10.0), 1, sin(pi - pi / 10.0), sin(pi + 3 * pi / 10), sin(2 * pi - 3 * pi / 10)};\n\n  for(int x = 0; x < 239; x++) {\n    double mappedX = (x * 2.0 / 239.0 - 1) * -1;\n    for(int y = 10; y < 249; y++) {\n      double mappedY = ((y-10) * 2.0 / 239.0 - 1) * -1;\n\n      if(mappedY > yVals[0]) {\n        if(!aboveLine(mappedX, mappedY, xVals[1], yVals[1], xVals[3], yVals[3]) && !aboveLine(mappedX, mappedY, xVals[1], yVals[1], xVals[4], yVals[4])) {\n          Brain.Screen.drawPixel(x, y);\n        }\n      } else if(aboveLine(mappedX, mappedY, xVals[2], yVals[2], xVals[4], yVals[4])) {\n        if(aboveLine(mappedX, mappedY, xVals[0], yVals[0], xVals[3], yVals[3])) {\n          Brain.Screen.drawPixel(x, y);\n        } else if(!aboveLine(mappedX, mappedY, xVals[1], yVals[1], xVals[4], yVals[4])) {\n          Brain.Screen.drawPixel(x, y);\n        }\n      } else if(aboveLine(mappedX, mappedY, xVals[0], yVals[0], xVals[3], yVals[3]) && !aboveLine(mappedX, mappedY, xVals[1], yVals[1], xVals[3], yVals[3])) {\n        Brain.Screen.drawPixel(x, y);\n      }\n    }\n  }\n}\n\nvoid drawTexanFlag() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(blue);\n  Brain.Screen.drawRectangle(0, 0, 239, 239);\n  Brain.Screen.setFillColor(white);\n  Brain.Screen.drawRectangle(239, 0, 239, 239 / 2);\n  Brain.Screen.setFillColor(red);\n  Brain.Screen.drawRectangle(239, 239 / 2, 239, 239);\n  \n  Brain.Screen.setFillColor(white);\n  drawStar();\n}\n\ndouble biState = 0;\ndouble tpState = 0;\ndouble tiState = 0;\ndouble mpState = 0;\ndouble counter = 0;\nint brainWidth = 480;\nint brainHeight = 240;\n\nbool isIntaking = false;\nbool isOutaking = false;\nbool isRedAlliance = true;\nbool isRightSide = false;\nbool isMatchloaderDown = false;\nbool isDescorerUp = false;;\n\nbool testingMode = false;\nbool isSkills = false;\n\nbool isHoldingPosition = false;\ndouble holdAngle = 0;\n\nvoid drawTwoOptions(vex::color col1, vex::color col2) {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(col1);\n  Brain.Screen.drawRectangle(0, 0, brainWidth / 2, brainHeight);\n  Brain.Screen.setFillColor(col2);\n  Brain.Screen.drawRectangle(brainWidth / 2, 0, brainWidth / 2, brainHeight);\n}\n\nvoid waitUntilBrainIsPressed() {\n  while (!Brain.Screen.pressing()) {\n    wait(0.1, seconds);\n  }\n  while (Brain.Screen.pressing()) {\n    wait(0.1, seconds);\n  }\n}\n\nvoid drawSelectedAutonAndAlliance() {\n  if(isRedAlliance) {\n    Brain.Screen.setFillColor(red);\n  } else {\n    Brain.Screen.setFillColor(blue);\n  }\n  Brain.Screen.drawRectangle(0, 0, brainWidth, brainHeight);\n  Brain.Screen.setCursor(1, 1);\n  Brain.Screen.print(isRightSide ? \"Right Auton\" : \"Left Auton\");\n}\n\nvoid setAlliance() {\n  drawTwoOptions(red, blue);\n  waitUntilBrainIsPressed();\n\n  if(Brain.Screen.xPosition() < brainWidth / 2) {\n    isRedAlliance = true;\n  } else {\n    isRedAlliance = false;\n  }\n  Brain.Screen.clearScreen();\n\n  drawTwoOptions(orange, yellow);\n  waitUntilBrainIsPressed();\n  if(Brain.Screen.xPosition() > brainWidth / 2) {\n    isRightSide = true;\n  } else {\n    isRightSide = false;\n  }\n  drawSelectedAutonAndAlliance();\n}\n\nvoid intakeStop() {\n  isIntaking = false;\n  isOutaking = false;\n  biState = 0;\n  tpState = 0;\n  tiState = 0;\n  mpState = 0;\n}\n\nvoid intakeScoreTop() {\n  isIntaking = false;\n  isOutaking = true;\n  biState = 1;\n  tpState = 1;\n  tiState = 1;\n  mpState = 1;\n}\n\nvoid spinToScoreMiddle() {\n  biState = 1;\n  tpState = 0.5;\n  tiState = -1;\n  mpState = 0.5;\n}\n\nvoid intakeScoreMiddle() {\n  isOutaking = true;\n  isIntaking = false;\n  spinToScoreMiddle();\n  mpState = 1;\n  biState = 0.75;\n  tiState = -0.75;\n}\n\nvoid intakeStore() {\n  isIntaking = true;\n  isOutaking = false;\n  biState = 1;\n  tpState = -1;\n  tiState = 1;\n  mpState = 0.5;\n}\n\nvoid intakeUnstore() {\n  isIntaking = false;\n  isOutaking = true;\n  biState = -1;\n  tpState = -1;\n  tiState = -1;\n  mpState = 1;\n}\n\nvoid swapMatchloaderState() {\n  isMatchloaderDown = !isMatchloaderDown;\n  PnumaticLoader.set(isMatchloaderDown);\n}\n\nvoid swapDescorerState() {\n  isDescorerUp = !isDescorerUp;\n  Descorer.set(isDescorerUp);\n}\n\nvoid setVelocities(double per) {\n  BackLeft.setVelocity(per, percent);\n  BackRight.setVelocity(per, percent);\n  FrontRight.setVelocity(per, percent);\n  FrontLeft.setVelocity(per, percent);\n}\n\nvoid setStoppingTo(vex::brakeType b) {\n  BackLeft.setStopping(b);\n  BackRight.setStopping(b);\n  FrontRight.setStopping(b);\n  FrontLeft.setStopping(b);\n}\n\nvoid holdState() {\n  double volts = abs(InertialSensor.rotation(degrees) - holdAngle) * 0.7;\n  if(InertialSensor.rotation(degrees) > holdAngle + 3) {\n    BackLeft.spin(reverse, volts, volt);\n    FrontLeft.spin(reverse, volts, volt);\n    BackRight.spin(forward, volts, volt);\n    FrontRight.spin(forward, volts, volt);\n  } else if(InertialSensor.rotation(degrees) < holdAngle - 3) {\n    BackRight.spin(reverse, volts, volt);\n    FrontRight.spin(reverse, volts, volt);\n    BackLeft.spin(forward, volts, volt);\n    FrontLeft.spin(forward, volts, volt);\n  } else {\n    BackRight.stop();\n    FrontRight.stop();\n    BackLeft.stop();\n    FrontLeft.stop();\n  }\n}\n\nvoid updateHoldingPosition() {\n  if(!isHoldingPosition) {\n    if(isOutaking && abs(Controller1.Axis3.position()) < 5 && abs(Controller1.Axis1.position()) < 5) {\n      isHoldingPosition = true;\n      holdAngle = InertialSensor.rotation(degrees);\n    } else {\n      return;\n    }\n  } else {\n    if(!(isOutaking && abs(Controller1.Axis3.position()) < 5 && abs(Controller1.Axis1.position()) < 5)) {\n      isHoldingPosition = false;\n      return;\n    }\n  }\n  Controller1.Screen.setCursor(1, 1);\n  Controller1.Screen.print(holdAngle);\n  Controller1.Screen.setCursor(2, 1);\n  Controller1.Screen.print(InertialSensor.rotation(degrees));\n  holdState();\n}\n\nvoid updateMovementMotors() {\n  double multiplier = 1;\n  if(testingMode) {\n    multiplier = 0.5;\n  }\n  if(isHoldingPosition) {\n    return;\n  }\n  FrontRight.spin(forward, multiplier * (Controller1.Axis3.position() - Controller1.Axis1.position()) / 90.0 * 12, volt);\n  BackRight.spin(forward, multiplier * (Controller1.Axis3.position() - Controller1.Axis1.position()) / 90.0 * 12, volt);\n  FrontLeft.spin(forward, multiplier * (Controller1.Axis3.position() + Controller1.Axis1.position()) / 90.0 * 12, volt);\n  BackLeft.spin(forward, multiplier * (Controller1.Axis3.position() + Controller1.Axis1.position()) / 90.0 * 12, volt);\n}\n\nbool doesSeeFriendlyCube() {\n  vision::signature friendlyCube = (isRedAlliance ? ColorSorter__REDCUBE : ColorSorter__BLUECUBE);\n  ColorSorter.takeSnapshot(friendlyCube);\n  return ColorSorter.objectCount > 0;\n}\n\nbool doesSeeEnemyCube() {\n  vision::signature hostileCube = (isRedAlliance ? ColorSorter__BLUECUBE : ColorSorter__REDCUBE);\n  ColorSorter.takeSnapshot(hostileCube);\n  return ColorSorter.objectCount > 0;\n}\n\nvoid updateColorFilter() {\n  if(!isIntaking) { return; }\n\n  if(counter > 2 && doesSeeEnemyCube()) {\n    spinToScoreMiddle();\n    counter = 0;\n  } else if(counter > 5 && doesSeeFriendlyCube()) {\n    counter = 0;\n    intakeStore();\n  }\n\n  counter++;\n}\n\n\n\nvoid updateBasketShaker() {\n  if(isOutaking) {\n    Shaker.spin(reverse, 5, volt);\n  } else if(isIntaking) {\n    Shaker.spin(forward, 5, volt);\n  } else {\n    Shaker.stop();\n  }\n}\n\nvoid updateIntakeMotors() {\n  updateColorFilter();\n  BottomIntake.spin(forward, 10 * biState, volt);\n  TopPole.spin(forward, 11 * tpState, volt);\n  TopIntake.spin(forward, 5.5 * tiState, volt);\n  MiddlePole.spin(forward, 5.5 * mpState, volt);\n\n  updateBasketShaker();\n}\n\nvoid driveForeward(double squares) {\n  double constant = 24 / (3.25 * 3.1415926535);\n  BackRight.spinFor(forward, squares * constant, turns, false);\n  FrontRight.spinFor(forward, squares * constant, turns, false);\n  BackLeft.spinFor(forward, squares * constant, turns, false);\n  FrontLeft.spinFor(forward, squares * constant, turns);\n  // wait(0.1, seconds);\n}\n\nvoid driveForeward() {\n  BackRight.spin(forward);\n  FrontRight.spin(forward);\n  BackLeft.spin(forward);\n  FrontLeft.spin(forward);\n}\n\nvoid stopDriveMotors() {\n  FrontRight.stop();\n  BackRight.stop();\n  FrontLeft.stop();\n  BackLeft.stop();\n}\n\n\nvoid turnRight(double degree) {\n  double sign = degree < 0.0 ? -1.0 : 1.0;\n  double origionalDegree = InertialSensor.rotation(degrees);\n\n  while (sign * (InertialSensor.rotation(degrees) - origionalDegree) + 5 < sign * degree) {\n    double amountLeft = sign * (degree - (InertialSensor.rotation(degrees) - origionalDegree));\n    FrontRight.spin(reverse, sign * (amountLeft / 120.0 * 8.0 + 2), volt);\n    BackRight.spin(reverse, sign * (amountLeft / 120.0 * 8.0 + 2), volt);\n    FrontLeft.spin(forward, sign * (amountLeft / 120.0 * 8.0 + 2), volt);\n    BackLeft.spin(forward, sign * (amountLeft / 120.0 * 8.0 + 2), volt);\n    wait(2, msec);\n  }\n\n  stopDriveMotors();\n}\n\nvoid turnLeft(double degree) {\n  turnRight(-degree);\n}\n\nvoid intakeGentler() {\n  biState = biState * 0.6;\n}\n\nvoid intakeFor(double sec) {\n  for(int i = 0; i < sec / 0.05; i++) {\n    updateIntakeMotors();\n    wait(0.05, seconds);\n  }\n}\n\nvoid rightAutonomous() {\n  setVelocities(80);\n  setStoppingTo(hold);\n\n\n  // setVelocities(80);\n  // setStoppingTo(hold);\n  // intakeStore();\n  // updateIntakeMotors();\n  // // turnLeft(3);\n  // driveForeward(0.5);\n  // turnRight(45);\n  // driveForeward(1.4 / sqrt(2));\n  // turnLeft(88);\n  // setVelocities(60);\n  // driveForeward(2.1 / sqrt(2));\n  // driveForeward(-0.2 / sqrt(2));\n  // driveForeward(-0.07);\n  // // driveForeward(-0.1 / sqrt(2));\n  // // wait(0.2, seconds);\n  // // driveForeward(1 / sqrt(2));\n  // setVelocities(80);\n\n  // // wait(2, seconds);\n\n  // // driveForeward(0.55);\n  // intakeUnstore();\n  // intakeGentler();\n  // intakeFor(6);\n  // intakeStop();\n  // updateIntakeMotors();\n  // driveForeward(-0.5);\n  \n}\nvoid leftAutonomous() {\n  setVelocities(80);\n  setStoppingTo(hold);\n\n  intakeStore();\n  // updateIntakeMotors();\n\n  driveForeward(0.55);\n  turnLeft(90);\n  // swapDescorerState();\n  driveForeward(1.3);\n  turnLeft(90);\n  swapMatchloaderState();\n  wait(0.1, seconds);\n  driveForeward(0.3);\n\n  setVelocities(10);\n  driveForeward();\n  // intakeFor(3);\n  wait(0.7, seconds);\n  stopDriveMotors();\n  setVelocities(80);\n  driveForeward(0.1);\n  driveForeward(-0.1);\n  driveForeward(0.1);\n  driveForeward(-0.1);\n  driveForeward();\n  wait(0.2, seconds);\n  // driveForeward(-0.3);\n  // wait(0.2, seconds);\n  // driveForeward(0.4);\n  // wait(0.2, seconds);\n  driveForeward(-0.7);\n  swapMatchloaderState();\n  turnLeft(40 + 90);\n  driveForeward(1.45);\n  turnLeft(15);\n  // return;\n  driveForeward(0.3);\n  intakeScoreMiddle();\n  wait(3, seconds);\n  // driveForeward(-1);\n  // turnRight(195);\n\n  // wait(1, seconds);\n  // intakeStore();\n  // updateIntakeMotors();\n  // // turnLeft(3);\n  // driveForeward(0.55);\n  // turnLeft(45);\n  // driveForeward(1.27 / sqrt(2));\n  // turnRight(91.5);\n\n  // driveForeward(1.55 / sqrt(2));\n  // swapMatchloaderState();\n  // wait(1, seconds);\n  // driveForeward(0.31 / sqrt(2));\n  // driveForeward(-0.05);\n\n  // wait(2, seconds);\n\n  // // driveForeward(0.55);\n  // intakeScoreMiddle();\n  // intakeFor(5);\n  intakeStop();\n  updateIntakeMotors();\n  // driveForeward(-0.5);\n}\n\nvoid skillsAutonomous() {\n  // InertialSensor.calibrate();\n}\n\nvoid runIntakeMotors() {\n  while(true) {\n    updateIntakeMotors();\n    wait(20, msec);\n  }\n}\n\nvoid autonomous() {\n  thread aThread = thread(runIntakeMotors);\n  drawTexanFlag();\n  if(isSkills) {\n    skillsAutonomous();\n    return;\n  }\n  if(isRightSide) {\n    rightAutonomous();\n  } else {\n    leftAutonomous();\n  }\n\n}\n\nvoid userControl() {\n  Brain.Timer.clear();\n  InertialSensor.calibrate();\n  wait(2, seconds);\n\n  thread aThread = thread(runIntakeMotors);\n\n  // place driver control in this while loop\n  while (true) {\n    if(60 + 30 <= Brain.Timer.time(seconds) && 60 + 30 + 1 >= Brain.Timer.time(seconds)) {\n      Controller1.rumble(rumbleLong);\n    }\n    if(testingMode) {\n      wait(20, msec);\n      continue;\n    }\n    updateHoldingPosition();\n    updateMovementMotors();\n    wait(20, msec);\n  }\n}\n\n\nvoid turnRightTester() {\n  setVelocities(100);\n  while(Controller1.ButtonA.pressing()) {\n    driveForeward(0.3);\n    driveForeward(-0.1);\n  }\n}\n\nvoid alterTestingVar() {\n  testingMode = !testingMode;\n}\n\nvoid preAutonomous() {\n  // actions to do when the program starts\n  Controller1.ButtonX.pressed(intakeStop);\n  Controller1.ButtonR1.pressed(intakeScoreTop);\n  Controller1.ButtonR2.pressed(intakeScoreMiddle);\n  Controller1.ButtonL1.pressed(intakeStore);\n  Controller1.ButtonL2.pressed(intakeUnstore);\n  Controller1.ButtonA.pressed(turnRightTester);\n  Controller1.ButtonB.pressed(alterTestingVar);\n  Controller1.ButtonUp.pressed(swapMatchloaderState);\n  Controller1.ButtonDown.pressed(swapDescorerState);\n  setAlliance();\n  \n  wait(1, seconds);\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  // create competition instance\n  competition Competition;\n\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n  while (true) {\n    wait(100, msec);\n  }\n}","textLanguage":"cpp","robotConfig":[{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[14],"name":"BackLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[6],"name":"BackRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[5],"name":"FrontRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[15],"name":"FrontLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[3],"name":"BottomIntake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[1],"name":"TopPole","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"TopIntake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[12],"name":"MiddlePole","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[11],"name":"ColorSorter","customName":true,"deviceType":"Vision","deviceClass":"vision","setting":{"config":"{\"config\":{\"brightness\":50,\"signatures\":[{\"name\":\"BLUECUBE\",\"parameters\":{\"uMin\":-4369,\"uMax\":-2803,\"uMean\":-3586,\"vMin\":6593,\"vMax\":8843,\"vMean\":7718,\"rgb\":1648711,\"type\":0,\"name\":\"BLUECUBE\"},\"range\":2.5},{\"name\":\"REDCUBE\",\"parameters\":{\"uMin\":11239,\"uMax\":13065,\"uMean\":12152,\"vMin\":-1663,\"vMax\":-429,\"vMean\":-1046,\"rgb\":5184794,\"type\":0,\"name\":\"REDCUBE\"},\"range\":2.5},{\"name\":\"SIG_3\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_3\"},\"range\":2.5},{\"name\":\"SIG_4\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_4\"},\"range\":2.5},{\"name\":\"SIG_5\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_5\"},\"range\":2.5},{\"name\":\"SIG_6\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_6\"},\"range\":2.5},{\"name\":\"SIG_7\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_7\"},\"range\":2.5}],\"codes\":[]}}","isConfigured":"false"},"triportSourcePort":22},{"port":[9],"name":"Shaker","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[10],"name":"InertialSensor","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[8],"name":"PnumaticLoader","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[7],"name":"Descorer","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.62.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"target":"Physical"}